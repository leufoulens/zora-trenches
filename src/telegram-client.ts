import TelegramBot from 'node-telegram-bot-api';
import { Creator, InlineKeyboardMarkup, InlineKeyboardButton, CreatedCoin } from './types';
import { config } from './config';
import { XApiClient } from './x-api-client';
import { FarcasterClient } from './farcaster-client';
import { RedisClient } from './redis-client';
import * as path from 'path';
import * as fs from 'fs';

export class TelegramClient {
  private bot: TelegramBot;
  private xApiClient: XApiClient;
  private farcasterClient: FarcasterClient;
  private redisClient: RedisClient;

  constructor(redisClient: RedisClient) {
    this.bot = new TelegramBot(config.telegramBotToken, { polling: false });
    this.xApiClient = new XApiClient();
    this.farcasterClient = new FarcasterClient();
    this.redisClient = redisClient;
  }

  startBot(): void {
    this.bot.startPolling();
    this.setupCommandHandlers();
    console.log('Telegram bot started and listening for commands');
  }

  stopBot(): void {
    this.bot.stopPolling();
    console.log('Telegram bot stopped');
  }

  private setupCommandHandlers(): void {

    // Command: /add_alpha_user - adds single user with optional description
    this.bot.onText(/\/add_alpha_user(?:\s+(.+))?/, async (msg, match) => {
      const chatId = msg.chat.id;
      const input = match?.[1];

      if (!input) {
        await this.bot.sendMessage(chatId, 
          '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_alpha_user username ["–æ–ø–∏—Å–∞–Ω–∏–µ –≤ –∫–∞–≤—ã—á–∫–∞—Ö"]\n' +
          '–ü—Ä–∏–º–µ—Ä—ã:\n' +
          '‚Ä¢ /add_alpha_user ufo\n' +
          '‚Ä¢ /add_alpha_user ufo "–°–æ–∑–¥–∞—Ç–µ–ª—å –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö NFT –∫–æ–ª–ª–µ–∫—Ü–∏–π"\n' +
          '‚Ä¢ /add_alpha_user wakeupremember "–≠–∫—Å–ø–µ—Ä—Ç –≤ –æ–±–ª–∞—Å—Ç–∏ DeFi –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç"'
        );
        return;
      }

      // Parse username and description with proper quote handling
      let username: string;
      let description: string | undefined;

      // Check if input contains quoted description
      const quoteMatch = input.match(/^(\S+)\s+"([^"]*)"$/);
      if (quoteMatch) {
        // Format: username "description"
        username = quoteMatch[1];
        description = quoteMatch[2].trim() || undefined;
      } else {
        // Format: username only (no quotes)
        username = input.trim();
        description = undefined;
      }

      if (!username.trim()) {
        await this.bot.sendMessage(chatId, '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å username');
        return;
      }

      try {
        const success = await this.redisClient.addToAlphaListWithDescription(username, description);
        const totalCount = await this.redisClient.getAlphaListCount();
        
        if (success) {
          let message = `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${username} –¥–æ–±–∞–≤–ª–µ–Ω –≤ alpha list`;
          if (description) {
            message += `\n–û–ø–∏—Å–∞–Ω–∏–µ: ${description}`;
          }
          message += `\n–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${totalCount}`;
          
          await this.bot.sendMessage(chatId, message);
        } else {
          await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ alpha list');
        }
      } catch (error) {
        console.error('Error in add_alpha_user command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ alpha list');
      }
    });

    // Command: /add_alpha_user_batch - adds multiple users with descriptions
    this.bot.onText(/\/add_alpha_user_batch(?:\s+([\s\S]+))?/, async (msg, match) => {
      const chatId = msg.chat.id;
      const input = match?.[1];

      if (!input) {
        await this.bot.sendMessage(chatId, 
          '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_alpha_user_batch\n' +
          '–§–æ—Ä–º–∞—Ç: username (–æ–ø–∏—Å–∞–Ω–∏–µ)\n\n' +
          '–ü—Ä–∏–º–µ—Ä:\n' +
          '0x0298f4332e3857631385b39766325058a93e249f (165–∫ —Ñ–æ–ª–ª–æ–≤–µ—Ä–æ–≤ —Ñ–∞—Ä–∫–∞—Å—Ç–µ—Ä, —Ñ–∞—É–Ω–¥–µ—Ä –∫–∞–∫–æ–≥–æ —Ç–æ —Ç–µ—Ö–∞ sablier, –º–æ–∂–Ω–æ –Ω–∞ –∫–æ–ø–µ–π–∫—É)\n' +
          '0x075b108fc0a6426f9dec9a5c18e87eb577d1346a (horsefacts –∞–¥–º–∏–Ω/–¥–µ–≤ —Ñ–∞—Ä–∫–∞—Å—Ç–µ—Ä–∞, –º–æ–∂–Ω–æ –Ω–∞ –∫–æ–ø–µ–π–∫—É)\n' +
          '0x081c7f89dffc2f618a0f4347c06fdf70f52e6510 (–ø—Ä–æ—Ñ–∏–ª—å kaloh –µ—â—ë –æ–¥–∏–Ω, –º–æ–∂–Ω–æ –Ω–∞ –∫–æ–ø–µ–π–∫—É)'
        );
        return;
      }

      try {
        // Parse each line: username (description)
        const lines = input.trim().split('\n').filter(line => line.trim());
        const users: { username: string; description: string }[] = [];
        const errors: string[] = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Match pattern: username (description)
          const match = line.match(/^([^\s(]+)\s*\(([^)]+)\)$/);
          
          if (match) {
            const username = match[1].trim();
            const description = match[2].trim();
            
            if (username && description) {
              users.push({ username, description });
            } else {
              errors.push(`–°—Ç—Ä–æ–∫–∞ ${i + 1}: –ø—É—Å—Ç–æ–π username –∏–ª–∏ –æ–ø–∏—Å–∞–Ω–∏–µ`);
            }
          } else {
            errors.push(`–°—Ç—Ä–æ–∫–∞ ${i + 1}: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç (–æ–∂–∏–¥–∞–µ—Ç—Å—è: username (–æ–ø–∏—Å–∞–Ω–∏–µ))`);
          }
        }

        if (users.length === 0) {
          await this.bot.sendMessage(chatId, 
            '–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è\n\n' +
            (errors.length > 0 ? `–û—à–∏–±–∫–∏:\n${errors.join('\n')}` : '')
          );
          return;
        }

        // Add users to alpha list
        let addedCount = 0;
        const addErrors: string[] = [];

        for (const user of users) {
          try {
            const success = await this.redisClient.addToAlphaListWithDescription(user.username, user.description);
            if (success) {
              addedCount++;
            } else {
              addErrors.push(`${user.username}: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏`);
            }
          } catch (error) {
            addErrors.push(`${user.username}: ${error}`);
          }
        }

        const totalCount = await this.redisClient.getAlphaListCount();

        // Prepare response message
        let message = `‚úÖ Batch –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ\n\n`;
        message += `–î–æ–±–∞–≤–ª–µ–Ω–æ: ${addedCount} –∏–∑ ${users.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n`;
        message += `–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ alpha list: ${totalCount}\n\n`;

        if (addedCount > 0) {
          message += `–£—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω—ã:\n`;
          users.slice(0, addedCount).forEach((user, index) => {
            message += `${index + 1}. ${user.username}\n   üìù ${user.description}\n\n`;
          });
        }

        if (errors.length > 0) {
          message += `\n–û—à–∏–±–∫–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:\n${errors.join('\n')}\n\n`;
        }

        if (addErrors.length > 0) {
          message += `\n–û—à–∏–±–∫–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è:\n${addErrors.join('\n')}`;
        }

        // Split message if too long (Telegram limit)
        if (message.length > 4000) {
          const chunks = this.splitMessage(message, 4000);
          for (const chunk of chunks) {
            await this.bot.sendMessage(chatId, chunk);
          }
        } else {
          await this.bot.sendMessage(chatId, message);
        }

      } catch (error) {
        console.error('Error in add_alpha_user_batch command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ batch –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ alpha list');
      }
    });

    // Command: /alpha_list
    this.bot.onText(/\/alpha_list/, async (msg) => {
      const chatId = msg.chat.id;

      try {
        const alphaListWithDescriptions = await this.redisClient.getAlphaListWithDescriptions();
        
        if (alphaListWithDescriptions.length === 0) {
          await this.bot.sendMessage(chatId, 'Alpha list –ø—É—Å—Ç');
          return;
        }

        const message = `üìã Alpha List (${alphaListWithDescriptions.length} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π):\n\n` +
          alphaListWithDescriptions.map((item, index) => {
            let userLine = `${index + 1}. ${item.username}`;
            if (item.description) {
              userLine += `\n   üìù ${item.description}`;
            }
            return userLine;
          }).join('\n\n');

        // Split message if too long (Telegram limit)
        if (message.length > 4000) {
          const chunks = this.splitMessage(message, 4000);
          for (const chunk of chunks) {
            await this.bot.sendMessage(chatId, chunk);
          }
        } else {
          await this.bot.sendMessage(chatId, message);
        }
      } catch (error) {
        console.error('Error in alpha_list command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ alpha list');
      }
    });

    // Command: /remove_alpha_user
    this.bot.onText(/\/remove_alpha_user(?:\s+(.+))?/, async (msg, match) => {
      const chatId = msg.chat.id;
      const username = match?.[1]?.trim();

      if (!username) {
        await this.bot.sendMessage(chatId, 
          '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /remove_alpha_user username\n' +
          '–ü—Ä–∏–º–µ—Ä: /remove_alpha_user ufo'
        );
        return;
      }

      try {
        const removed = await this.redisClient.removeFromAlphaList(username);
        const totalCount = await this.redisClient.getAlphaListCount();
        
        if (removed) {
          await this.bot.sendMessage(chatId, 
            `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${username} —É–¥–∞–ª–µ–Ω –∏–∑ alpha list\n` +
            `–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${totalCount}`
          );
        } else {
          await this.bot.sendMessage(chatId, 
            `‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${username} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ alpha list`
          );
        }
      } catch (error) {
        console.error('Error in remove_alpha_user command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ alpha list');
      }
    });

    // Command: /add_twitter_blacklist
    this.bot.onText(/\/add_twitter_blacklist(?:\s+(.+))?/, async (msg, match) => {
      const chatId = msg.chat.id;
      const usernames = match?.[1];

      if (!usernames) {
        await this.bot.sendMessage(chatId, 
          '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /add_twitter_blacklist username1 username2 username3\n' +
          '–ü—Ä–∏–º–µ—Ä: /add_twitter_blacklist baduser1 spammer2 scammer3'
        );
        return;
      }

      const usernameList = usernames.split(/\s+/).filter(u => u.trim());
      if (usernameList.length === 0) {
        await this.bot.sendMessage(chatId, '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω Twitter username');
        return;
      }

      try {
        const addedCount = await this.redisClient.addToTwitterBlacklist(usernameList);
        const totalCount = await this.redisClient.getTwitterBlacklistCount();
        
        await this.bot.sendMessage(chatId, 
          `üö´ –î–æ–±–∞–≤–ª–µ–Ω–æ ${addedCount} –Ω–æ–≤—ã—Ö Twitter –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –≤ blacklist\n` +
          `–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: ${totalCount}\n\n` +
          `–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ Twitter usernames:\n${usernameList.map(u => `‚Ä¢ @${u}`).join('\n')}`
        );
      } catch (error) {
        console.error('Error in add_twitter_blacklist command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ Twitter blacklist');
      }
    });

    // Command: /twitter_blacklist
    this.bot.onText(/\/twitter_blacklist/, async (msg) => {
      const chatId = msg.chat.id;

      try {
        const blacklist = await this.redisClient.getTwitterBlacklist();
        
        if (blacklist.length === 0) {
          await this.bot.sendMessage(chatId, 'Twitter blacklist –ø—É—Å—Ç');
          return;
        }

        const message = `üö´ Twitter Blacklist (${blacklist.length} –∞–∫–∫–∞—É–Ω—Ç–æ–≤):\n\n` +
          blacklist.map((username, index) => `${index + 1}. @${username}`).join('\n');

        // Split message if too long (Telegram limit)
        if (message.length > 4000) {
          const chunks = this.splitMessage(message, 4000);
          for (const chunk of chunks) {
            await this.bot.sendMessage(chatId, chunk);
          }
        } else {
          await this.bot.sendMessage(chatId, message);
        }
      } catch (error) {
        console.error('Error in twitter_blacklist command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ Twitter blacklist');
      }
    });

    // Command: /remove_twitter_blacklist
    this.bot.onText(/\/remove_twitter_blacklist(?:\s+(.+))?/, async (msg, match) => {
      const chatId = msg.chat.id;
      const username = match?.[1]?.trim();

      if (!username) {
        await this.bot.sendMessage(chatId, 
          '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /remove_twitter_blacklist username\n' +
          '–ü—Ä–∏–º–µ—Ä: /remove_twitter_blacklist baduser1'
        );
        return;
      }

      try {
        const removed = await this.redisClient.removeFromTwitterBlacklist(username);
        const totalCount = await this.redisClient.getTwitterBlacklistCount();
        
        if (removed) {
          await this.bot.sendMessage(chatId, 
            `‚úÖ Twitter –∞–∫–∫–∞—É–Ω—Ç @${username} —É–¥–∞–ª–µ–Ω –∏–∑ blacklist\n` +
            `–û—Å—Ç–∞–ª–æ—Å—å –∞–∫–∫–∞—É–Ω—Ç–æ–≤: ${totalCount}`
          );
        } else {
          await this.bot.sendMessage(chatId, 
            `‚ùå Twitter –∞–∫–∫–∞—É–Ω—Ç @${username} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ blacklist`
          );
        }
      } catch (error) {
        console.error('Error in remove_twitter_blacklist command:', error);
        await this.bot.sendMessage(chatId, '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ Twitter blacklist');
      }
    });

    // Callback handler for blacklist Twitter button
    this.bot.on('callback_query', async (callbackQuery) => {
      const chatId = callbackQuery.message?.chat.id;
      const messageId = callbackQuery.message?.message_id;
      const data = callbackQuery.data;

      if (!chatId || !messageId || !data) return;

      if (data.startsWith('blacklist_twitter:')) {
        const twitterUsername = data.split(':')[1];
        
        try {
          // Check if already in blacklist
          const isAlreadyBlacklisted = await this.redisClient.isInTwitterBlacklist(twitterUsername);
          
          if (isAlreadyBlacklisted) {
            await this.bot.answerCallbackQuery(callbackQuery.id, {
              text: `@${twitterUsername} —É–∂–µ –≤ blacklist`,
              show_alert: true
            });
            return;
          }

          // Add to blacklist
          await this.redisClient.addToTwitterBlacklist([twitterUsername]);
          const totalCount = await this.redisClient.getTwitterBlacklistCount();

          // Send confirmation message
          await this.bot.sendMessage(chatId, 
            `üö´ Twitter –∞–∫–∫–∞—É–Ω—Ç @${twitterUsername} –¥–æ–±–∞–≤–ª–µ–Ω –≤ blacklist\n` +
            `–í—Å–µ–≥–æ –≤ blacklist: ${totalCount} –∞–∫–∫–∞—É–Ω—Ç–æ–≤`
          );

          // Answer callback query
          await this.bot.answerCallbackQuery(callbackQuery.id, {
            text: `@${twitterUsername} –¥–æ–±–∞–≤–ª–µ–Ω –≤ blacklist`,
            show_alert: false
          });

          console.log(`Twitter @${twitterUsername} added to blacklist via button`);
        } catch (error) {
          console.error('Error in blacklist_twitter callback:', error);
          await this.bot.answerCallbackQuery(callbackQuery.id, {
            text: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ blacklist',
            show_alert: true
          });
        }
      }
    });
  }

  private splitMessage(message: string, maxLength: number): string[] {
    const chunks: string[] = [];
    const lines = message.split('\n');
    let currentChunk = '';

    for (const line of lines) {
      if ((currentChunk + line + '\n').length > maxLength) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          currentChunk = '';
        }
        
        // If single line is too long, split it
        if (line.length > maxLength) {
          const words = line.split(' ');
          for (const word of words) {
            if ((currentChunk + word + ' ').length > maxLength) {
              if (currentChunk) {
                chunks.push(currentChunk.trim());
                currentChunk = '';
              }
            }
            currentChunk += word + ' ';
          }
        } else {
          currentChunk = line + '\n';
        }
      } else {
        currentChunk += line + '\n';
      }
    }

    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }

  private escapeMarkdown(text: string): string {
    // Escape special Markdown characters for Telegram
    return text.replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&');
  }

  private formatUsernameLink(username: string, platform: 'zora' | 'farcaster' | 'twitter'): string {
    const baseUrls = {
      zora: 'https://zora.co',
      farcaster: 'https://warpcast.com',
      twitter: 'https://x.com'
    };
    
    const url = `${baseUrls[platform]}/${username}`;
    // Don't escape username inside markdown links - it will show escaped characters
    return `[@${username}](${url})`;
  }

  private getFollowerIndicator(followerCount: number): string {
    if (followerCount < 50) {
      return 'üî¥'; // –∫—Ä–∞—Å–Ω—ã–π –∫—Ä—É–≥ –¥–ª—è –º–µ–Ω–µ–µ 50 –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
    } else if (followerCount < 1000) {
      return 'üü°'; // –∂–µ–ª—Ç—ã–π –∫—Ä—É–≥ –¥–ª—è 50-999 –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
    } else {
      return 'üü¢'; // –∑–µ–ª–µ–Ω—ã–π –∫—Ä—É–≥ –¥–ª—è 1000+ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
    }
  }

  private getMaxMarketCapToken(creator: Creator): { token: CreatedCoin; marketCap: number } | null {
    if (!creator.creatorProfile.createdCoins.edges.length) {
      return null;
    }

    let maxToken: CreatedCoin | null = null;
    let maxMarketCap = 0;

    for (const edge of creator.creatorProfile.createdCoins.edges) {
      const token = edge.node;
      const marketCap = parseFloat(token.marketCap) || 0;
      
      if (marketCap > maxMarketCap) {
        maxMarketCap = marketCap;
        maxToken = token;
      }
    }

    return maxToken ? { token: maxToken, marketCap: maxMarketCap } : null;
  }

  private async formatCreatorMessage(creator: Creator, reason?: string, alphaDescription?: string): Promise<string> {
    const { address, name, createdAt, creatorProfile } = creator;
    const { followedEdges, username, socialAccounts, vcFollowingStatus, createdCoins, followersInVcFollowing } = creatorProfile;
    const followerIndicator = this.getFollowerIndicator(followedEdges.count);
    
    let message = `NEW CREATOR\n\n`;
    
    // Add reason at the beginning if provided
    if (reason) {
      message = `${reason}\n`;
      
      // Add alpha description if this is an ALPHA USER and description exists
      if (reason === 'ALPHA USER' && alphaDescription) {
        message += `üìù ${alphaDescription}\n`;
      }
      
      message += `\nNEW CREATOR\n\n`;
    }
    
    message += `Name: ${this.escapeMarkdown(name)}\n`;
    message += `Address: \`${address}\`\n`;
    message += `Followers: ${followedEdges.count} ${followerIndicator}\n`;
    
    // Add vcFollowingStatus and VC followers count if FOLLOWING
    if (vcFollowingStatus && vcFollowingStatus === 'FOLLOWING') {
      message += `VC Following: ${this.escapeMarkdown(vcFollowingStatus)} (${followersInVcFollowing.count} VC followers)\n`;
    } else if (vcFollowingStatus && vcFollowingStatus !== 'UNKNOWN') {
      message += `VC Following: ${this.escapeMarkdown(vcFollowingStatus)}\n`;
    }
    
    message += `Created: ${this.escapeMarkdown(new Date(createdAt).toLocaleString('en-US'))}\n`;
    
    if (username) {
      const usernameLink = this.formatUsernameLink(username, 'zora');
      message += `Username: ${usernameLink}\n`;
    }

    // Add best token info if exists
    const maxTokenInfo = this.getMaxMarketCapToken(creator);
    if (maxTokenInfo && maxTokenInfo.marketCap > 0) {
      message += `\nBest Token:\n`;
      message += `  Name: ${this.escapeMarkdown(maxTokenInfo.token.name)}\n`;
      message += `  Market Cap: $${maxTokenInfo.marketCap.toLocaleString('en-US')}\n`;
      message += `  Address: \`${maxTokenInfo.token.address}\`\n`;
    } else if (createdCoins.edges.length > 0) {
      message += `\nCreated Tokens: ${createdCoins.edges.length}\n`;
    }

    // Add Farcaster with followers and clickable link
    if (socialAccounts.farcaster?.displayName || socialAccounts.farcaster?.username) {
      message += `\nFarcaster:\n`;
      if (socialAccounts.farcaster.displayName) {
        message += `  Name: ${this.escapeMarkdown(socialAccounts.farcaster.displayName)}\n`;
      }
      if (socialAccounts.farcaster.username) {
        // Get follower count via Farcaster API
        const farcasterData = await this.getFarcasterData(socialAccounts.farcaster.username);
        const usernameLink = this.formatUsernameLink(socialAccounts.farcaster.username, 'farcaster');
        
        if (farcasterData) {
          message += `  ${usernameLink} (${farcasterData.followers.toLocaleString('en-US')} followers)\n`;
        } else {
          message += `  ${usernameLink}\n`;
        }
      }
    }

    // Add Twitter with followers and clickable link
    if (socialAccounts.twitter?.displayName || socialAccounts.twitter?.username) {
      message += `\nTwitter:\n`;
      if (socialAccounts.twitter.displayName) {
        message += `  Name: ${this.escapeMarkdown(socialAccounts.twitter.displayName)}\n`;
      }
      if (socialAccounts.twitter.username) {
        // Get follower count via X API
        const followersCount = await this.getTwitterFollowers(socialAccounts.twitter.username);
        const usernameLink = this.formatUsernameLink(socialAccounts.twitter.username, 'twitter');
        
        if (followersCount !== null) {
          message += `  ${usernameLink} (${followersCount.toLocaleString('en-US')} followers)\n`;
        } else {
          message += `  ${usernameLink}\n`;
        }
      }
    }

    // Add prefix for high follower count (only if no reason provided)
    if (!reason && followedEdges.count >= config.highFollowersThreshold) {
      message = `HIGH VALUE CREATOR\n\n` + message;
    }

    return message;
  }

  private getCreatorKeyboardMarkup(creator: Creator): InlineKeyboardMarkup {
    const address = creator.address;
    const twitterUsername = creator.creatorProfile.socialAccounts.twitter?.username;
    
    const keyboard: InlineKeyboardButton[][] = [
      [
        { 
          text: 'Based Bot', 
          url: `https://t.me/based_eth_bot?start=r_worldfinaltour_b_${address}` 
        }
      ],
      [
        {
          text: 'DexScreener', 
          url: `https://dexscreener.com/base/${address}` 
        }
      ]
    ];

    // Add blacklist button if Twitter is connected
    if (twitterUsername) {
      keyboard.push([
        {
          text: 'üö´ Blacklist Twitter',
          callback_data: `blacklist_twitter:${twitterUsername}`
        }
      ]);
    }
    
    return {
      inline_keyboard: keyboard
    };
  }

  private async getTwitterFollowers(username: string): Promise<number | null> {
    try {
      return await this.xApiClient.getFollowersCount(username);
    } catch (error) {
      console.error(`Error getting X followers for @${username}:`, error);
      return null;
    }
  }

  private async getFarcasterData(username: string): Promise<{ followers: number; following: number } | null> {
    try {
      return await this.farcasterClient.getUserData(username);
    } catch (error) {
      console.error(`Error getting Farcaster data for @${username}:`, error);
      return null;
    }
  }

  async sendToGeneral(creator: Creator): Promise<void> {
    try {
      const message = await this.formatCreatorMessage(creator);
      const keyboard = this.getCreatorKeyboardMarkup(creator);
      
      await this.bot.sendMessage(config.telegramChatGeneral, message, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        reply_markup: keyboard
      });
      console.log(`Sent to general chat: ${creator.name} (${creator.address})`);
    } catch (error) {
      console.error(`Error sending to general chat for ${creator.address}:`, error);
      // Fallback: try sending without Markdown if it fails
      try {
        const plainMessage = await this.formatCreatorMessage(creator);
        const escapedMessage = plainMessage.replace(/[`*_[\]()]/g, '');
        await this.bot.sendMessage(config.telegramChatGeneral, escapedMessage);
        console.log(`Sent fallback message to general chat: ${creator.name}`);
      } catch (fallbackError) {
        console.error(`Fallback also failed for ${creator.address}:`, fallbackError);
      }
    }
  }

  async sendToHigh(creator: Creator, reason: string, alphaDescription?: string): Promise<void> {
    try {
      const message = await this.formatCreatorMessage(creator, reason, alphaDescription);
      const keyboard = this.getCreatorKeyboardMarkup(creator);
      
      // Check if this is an ALPHA USER and image exists
      if (reason === 'ALPHA USER') {
        const imagePath = path.join(process.cwd(), 'public', 'alphaimage.png');
        
        if (fs.existsSync(imagePath)) {
          try {
            await this.bot.sendPhoto(config.telegramChatHigh, imagePath, {
              caption: message,
              parse_mode: 'Markdown',
              reply_markup: keyboard
            });
            console.log(`Sent to HIGH chat with image: ${creator.name} (ALPHA USER)`);
            return;
          } catch (photoError) {
            console.error(`Error sending photo for ALPHA USER ${creator.address}:`, photoError);
            // Fall through to send text message
          }
        } else {
          console.warn(`Alpha image not found at ${imagePath}`);
        }
      }
      
      // Send regular text message (either not ALPHA USER or image failed)
      await this.bot.sendMessage(config.telegramChatHigh, message, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        reply_markup: keyboard
      });
      console.log(`Sent to HIGH chat: ${creator.name} (${reason})`);
      
    } catch (error) {
      console.error(`Error sending to HIGH chat for ${creator.address}:`, error);
      // Fallback: try sending without Markdown if it fails
      try {
        const plainMessage = await this.formatCreatorMessage(creator, reason, alphaDescription);
        const escapedMessage = plainMessage.replace(/[`*_[\]()]/g, '');
        await this.bot.sendMessage(config.telegramChatHigh, escapedMessage);
        console.log(`Sent fallback message to HIGH chat: ${creator.name}`);
      } catch (fallbackError) {
        console.error(`Fallback also failed for ${creator.address}:`, fallbackError);
      }
    }
  }

  async sendStatusMessage(text: string): Promise<void> {
    try {
      const escapedText = this.escapeMarkdown(text);
      await this.bot.sendMessage(config.telegramChatGeneral, escapedText);
    } catch (error) {
      console.error('Error sending status message:', error);
      // Fallback: send plain text without escaping
      try {
        await this.bot.sendMessage(config.telegramChatGeneral, text);
      } catch (fallbackError) {
        console.error('Status message fallback failed:', fallbackError);
      }
    }
  }

  // Methods for cache statistics
  getXApiCacheSize(): number {
    return this.xApiClient.getCacheSize();
  }

  getFarcasterCacheSize(): number {
    return this.farcasterClient.getCacheSize();
  }

  // Methods for cache cleanup
  clearXApiCache(): void {
    this.xApiClient.clearCache();
  }

  clearFarcasterCache(): void {
    this.farcasterClient.clearCache();
  }

  clearAllSocialCaches(): void {
    this.clearXApiCache();
    this.clearFarcasterCache();
  }
} 